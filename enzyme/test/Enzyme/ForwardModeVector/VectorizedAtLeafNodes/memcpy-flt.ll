; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
; RUN: %opt < %s %loadEnzyme -enzyme -enzyme-preopt=false -enzyme-vectorize-at-leaf-nodes -mem2reg -simplifycfg -dce -instcombine -S | FileCheck %s

; Function Attrs: nounwind
declare void @__enzyme_fwddiff.f64(...)

; Function Attrs: nounwind uwtable
define dso_local void @memcpy_float(double* nocapture %dst, double* nocapture readonly %src, i64 %num) #0 {
entry:
  %0 = bitcast double* %dst to i8*
  %1 = bitcast double* %src to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 %1, i64 %num, i1 false)
  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #1

; Function Attrs: nounwind uwtable
define dso_local void @dmemcpy_float(double* %dst, <3 x double>* %dstp, double* %src, <3 x double>* %srcp, i64 %n) local_unnamed_addr #0 {
entry:
  tail call void (...) @__enzyme_fwddiff.f64(void (double*, double*, i64)* nonnull @memcpy_float, metadata !"enzyme_width", i64 3, double* %dst, <3 x double>* %dstp, double* %src, <3 x double>* %srcp, i64 %n) #3
  ret void
}

attributes #0 = { nounwind uwtable }
attributes #1 = { argmemonly nounwind }
attributes #2 = { noinline nounwind uwtable }


; CHECK: define internal void @fwddiffe3memcpy_float(double* nocapture %dst, <3 x double>* %"dst'", double* nocapture readonly %src, <3 x double>* %"src'", i64 %num)
; CHECK-NEXT:  entry:
; CHECK-NEXT:   %"'ipc" = bitcast <3 x double>* %"dst'" to <3 x i8>*
; CHECK-NEXT:   %0 = bitcast double* %dst to i8*
; CHECK-NEXT:   %"'ipc2" = bitcast <3 x double>* %"src'" to <3 x i8>*
; CHECK-NEXT:   %1 = bitcast double* %src to i8*
; CHECK-NEXT:   tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 %1, i64 %num, i1 false) #3
; CHECK-NEXT:   %2 = bitcast <3 x double>* %"dst'" to i8*
; CHECK-NEXT:   %3 = bitcast <3 x double>* %"src'" to i8*
; CHECK-NEXT:   tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 1 %3, i64 %num, i1 false) #3
; CHECK-NEXT:   %4 = getelementptr inbounds <3 x i8>, <3 x i8>* %"'ipc", i64 0, i64 1
; CHECK-NEXT:   %5 = getelementptr inbounds <3 x i8>, <3 x i8>* %"'ipc2", i64 0, i64 1
; CHECK-NEXT:   tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %4, i8* nonnull align 1 %5, i64 %num, i1 false) #3
; CHECK-NEXT:   %6 = getelementptr inbounds <3 x i8>, <3 x i8>* %"'ipc", i64 0, i64 2
; CHECK-NEXT:   %7 = getelementptr inbounds <3 x i8>, <3 x i8>* %"'ipc2", i64 0, i64 2
; CHECK-NEXT:   tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %6, i8* nonnull align 1 %7, i64 %num, i1 false) #3
; CHECK-NEXT:   ret void
; CHECK-NEXT: }